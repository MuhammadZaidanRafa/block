<!DOCTYPE html>
<html lang="id">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Block Puzzle Drag</title>

<style>
:root{
    --maxWidth: 460px;
    --cell: clamp(26px, 8vw, 44px);
    --gap: clamp(3px, 1.2vw, 6px);

    --gold: #ffcc00;
    --shadow: #c9a200;
}

*{box-sizing:border-box;}

body{
    margin:0;
    font-family: Arial, sans-serif;
    background: url("bg.jpeg") center/cover no-repeat fixed;
    min-height:100vh;
    color:white;
    user-select:none;

    display:flex;
    justify-content:center;
    align-items:flex-start;
    padding:14px;
}

.wrapper{
    width:100%;
    max-width: var(--maxWidth);
}

.game{
    width:100%;
    padding:12px;
    background: rgba(0,0,0,.62);
    border-radius:14px;
    backdrop-filter: blur(2px);
}

h2{
    text-align:center;
    margin:6px 0 8px 0;
    font-size:22px;
}

.score{
    text-align:center;
    margin-bottom:12px;
    font-size:18px;
}

/* BOARD */
.board{
    display:grid;
    grid-template-columns: repeat(8, var(--cell));
    gap: var(--gap);
    justify-content:center;

    background:#2a2a2a;
    padding: var(--gap);
    border-radius:12px;
}

.cell{
    width: var(--cell);
    height: var(--cell);
    background:#444;
    border-radius:6px;
}

.cell.filled{ background:#00e5ff; }
.cell.preview{ outline:2px solid rgba(255,255,0,0.7); }

/* BLOCKS */
.blocks{
    display:flex;
    justify-content:space-around;
    align-items:center;
    gap:10px;
    margin-top:14px;
    flex-wrap:nowrap;
}

.block{
    display:grid;
    gap: calc(var(--gap) - 1px);
    padding:8px;
    background:#222;
    border-radius:10px;
    touch-action:none;
}

.block div{
    width: var(--cell);
    height: var(--cell);
    background: gold;
    border-radius:6px;
}

/* FOOTER */
.footer{
    margin-top: 14px;
    display:flex;
    flex-direction:column;
    gap:10px;
    align-items:center;
}

.credit{
    text-align:center;
    font-size:12px;
    color:#00ff6a;
}

.btn-kembali{
    display:inline-block;
    padding:14px 30px;
    background: var(--gold);
    color:#000;
    font-size:18px;
    font-weight:bold;
    border-radius:14px;
    text-decoration:none;
    box-shadow:0 6px 0 var(--shadow);
    transition:0.2s;
}

.btn-kembali:hover{
    transform:translateY(-2px);
}

.btn-kembali:active{
    transform:translateY(4px);
    box-shadow:0 2px 0 var(--shadow);
}

/* GAME OVER */
.gameover{
    position:fixed;
    inset:0;
    background: rgba(0,0,0,0.85);
    display:none;
    justify-content:center;
    align-items:center;
    z-index:999;
    padding:20px;
}

.gameover-box{
    background:#111;
    padding:22px;
    border-radius:14px;
    text-align:center;
    width:min(320px, 92vw);
    box-shadow:0 0 20px rgba(255,255,255,0.18);
}

.gameover-box button{
    margin-top:12px;
    padding:12px 18px;
    border:none;
    border-radius:10px;
    background: gold;
    font-weight:bold;
    cursor:pointer;
}

/* GHOST DRAG */
.ghost{
    position:fixed;
    z-index:9999;
    pointer-events:none;
    opacity:0.85;
    transform: translate(-50%,-50%);
    display:grid;
    gap: calc(var(--gap) - 1px);
    padding:8px;
    background: rgba(0,0,0,0.35);
    border-radius:12px;
}

.ghost div{
    width: var(--cell);
    height: var(--cell);
    background: gold;
    border-radius:6px;
}

/* HP kecil */
@media (max-width:360px){
    h2{font-size:20px;}
    .score{font-size:16px;}
    .btn-kembali{font-size:16px;padding:12px 24px;}
}
</style>
</head>

<body>

<audio id="bgMusic" src="beach.mp3" loop></audio>

<div class="wrapper">
    <div class="game">
        <h2>Block Puzzle Drag</h2>
        <div class="score">Skor: <span id="score">0</span></div>

        <div class="board" id="board"></div>
        <div class="blocks" id="blocks"></div>

        <div class="footer">
            <div class="credit">made by Rafa and venom game</div>
            <a href="index.html" class="btn-kembali">Kembali</a>
        </div>
    </div>
</div>

<!-- GAME OVER -->
<div id="gameOver" class="gameover">
    <div class="gameover-box">
        <h2>GAME OVER</h2>
        <p>Skor Kamu: <span id="finalScore">0</span></p>
        <button onclick="restartGame()">Restart</button>
    </div>
</div>

<script>
/* AUDIO */
function aktifkanAudio(){
    const m = document.getElementById("bgMusic");
    m.play().catch(()=>{});
}
document.addEventListener("click", aktifkanAudio, { once:true });
document.addEventListener("touchstart", aktifkanAudio, { once:true });

/* GAME */
const boardSize = 8;
const board = document.getElementById("board");
const blocksEl = document.getElementById("blocks");
const scoreEl = document.getElementById("score");

const gameOverEl = document.getElementById("gameOver");
const finalScoreEl = document.getElementById("finalScore");

let score = 0;
let cells = [];

let draggingBlock = null;
let draggingShape = null;
let ghost = null;

/* papan */
for(let i=0;i<boardSize*boardSize;i++){
    const c = document.createElement("div");
    c.className = "cell";
    c.dataset.index = i;
    board.appendChild(c);
    cells.push(c);
}

/* bentuk */
const shapes = [
    [[1,1,1]],
    [[1,1],[1,1]],
    [[1],[1],[1]],
    [[1,1,1],[0,1,0]],
    [[1,1]]
];

function createBlocks(){
    blocksEl.innerHTML = "";

    for(let i=0;i<3;i++){
        const shape = shapes[Math.floor(Math.random()*shapes.length)];
        const b = document.createElement("div");
        b.className = "block";
        b.style.gridTemplateColumns = `repeat(${shape[0].length}, var(--cell))`;
        b.shapeData = shape;

        shape.flat().forEach(v=>{
            const d = document.createElement("div");
            if(!v) d.style.visibility="hidden";
            b.appendChild(d);
        });

        /* DRAG START */
        b.addEventListener("pointerdown",(e)=>{
            draggingBlock = b;
            draggingShape = b.shapeData;

            ghost = createGhost(draggingShape);
            document.body.appendChild(ghost);
            moveGhost(e.clientX, e.clientY);

            b.setPointerCapture(e.pointerId);
        });

        /* DRAG MOVE */
        b.addEventListener("pointermove",(e)=>{
            if(!draggingBlock) return;
            moveGhost(e.clientX, e.clientY);
            previewOnBoard(e.clientX, e.clientY);
            e.preventDefault();
        }, { passive:false });

        /* DRAG END */
        b.addEventListener("pointerup",(e)=>{
            if(!draggingBlock) return;

            const dropIndex = getCellIndexFromPoint(e.clientX, e.clientY);

            clearPreview();

            if(dropIndex !== null && canPlace(draggingShape, dropIndex)){
                place(draggingShape, dropIndex);
                draggingBlock.remove();

                checkLine();

                if(blocksEl.children.length === 0) createBlocks();
                if(isGameOver()) showGameOver();
            }

            if(ghost) ghost.remove();
            ghost = null;

            draggingBlock = null;
            draggingShape = null;
        });

        blocksEl.appendChild(b);
    }
}

/* ghost */
function createGhost(shape){
    const g = document.createElement("div");
    g.className = "ghost";
    g.style.gridTemplateColumns = `repeat(${shape[0].length}, var(--cell))`;

    shape.flat().forEach(v=>{
        const d = document.createElement("div");
        if(!v) d.style.visibility="hidden";
        g.appendChild(d);
    });

    return g;
}

function moveGhost(x,y){
    if(!ghost) return;
    ghost.style.left = x + "px";
    ghost.style.top = y + "px";
}

/* helper */
function getCellIndexFromPoint(x,y){
    const el = document.elementFromPoint(x,y);
    if(!el) return null;
    if(el.classList.contains("cell")) return parseInt(el.dataset.index);
    return null;
}

/* preview */
function clearPreview(){
    cells.forEach(c=>c.classList.remove("preview"));
}

function previewOnBoard(x,y){
    clearPreview();
    const index = getCellIndexFromPoint(x,y);
    if(index === null) return;
    if(!canPlace(draggingShape, index)) return;

    const startX = index % boardSize;
    const startY = Math.floor(index / boardSize);

    for(let r=0;r<draggingShape.length;r++){
        for(let c=0;c<draggingShape[r].length;c++){
            if(draggingShape[r][c]){
                const nx = startX + c;
                const ny = startY + r;
                cells[ny*boardSize + nx].classList.add("preview");
            }
        }
    }
}

function canPlace(shape,index){
    const x = index % boardSize;
    const y = Math.floor(index / boardSize);

    for(let r=0;r<shape.length;r++){
        for(let c=0;c<shape[r].length;c++){
            if(shape[r][c]){
                const nx = x + c;
                const ny = y + r;

                if(nx >= boardSize || ny >= boardSize) return false;
                if(cells[ny*boardSize + nx].classList.contains("filled")) return false;
            }
        }
    }
    return true;
}

function place(shape,index){
    const x = index % boardSize;
    const y = Math.floor(index / boardSize);

    shape.forEach((row,r)=>{
        row.forEach((v,c)=>{
            if(v){
                cells[(y+r)*boardSize + (x+c)].classList.add("filled");
            }
        });
    });
}

/* CEK BARIS & KOLOM */
function checkLine(){
    let cleared = 0;

    /* baris */
    for(let r=0;r<boardSize;r++){
        let full = true;
        for(let c=0;c<boardSize;c++){
            if(!cells[r*boardSize + c].classList.contains("filled")){
                full = false;
                break;
            }
        }
        if(full){
            for(let c=0;c<boardSize;c++){
                cells[r*boardSize + c].classList.remove("filled");
            }
            cleared++;
        }
    }

    /* kolom */
    for(let c=0;c<boardSize;c++){
        let full = true;
        for(let r=0;r<boardSize;r++){
            if(!cells[r*boardSize + c].classList.contains("filled")){
                full = false;
                break;
            }
        }
        if(full){
            for(let r=0;r<boardSize;r++){
                cells[r*boardSize + c].classList.remove("filled");
            }
            cleared++;
        }
    }

    if(cleared > 0){
        score += cleared * 10;
        scoreEl.textContent = score;
    }
}

/* GAME OVER */
function isGameOver(){
    const blocks = [...blocksEl.children];

    for(let b of blocks){
        const shape = b.shapeData;
        for(let i=0;i<boardSize*boardSize;i++){
            if(canPlace(shape,i)) return false;
        }
    }
    return true;
}

function showGameOver(){
    finalScoreEl.textContent = score;
    gameOverEl.style.display = "flex";
}

function restartGame(){
    cells.forEach(c=>c.classList.remove("filled"));
    score = 0;
    scoreEl.textContent = 0;

    createBlocks();
    gameOverEl.style.display = "none";
}

createBlocks();
</script>

</body>
</html>
